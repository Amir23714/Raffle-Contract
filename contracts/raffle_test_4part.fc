#include "imports/stdlib.fc";

const int const::deposit = 1040000000;
const int const::owner_fee = 1000000000;
const int const::min_balance = 10000000;

;; storage scheme
;; 1 - owner address
;; 2 - previous winner
;; 3 - total number of participants
;; 4 - dictionary of participants (after first participant entering)

() restart_raffle(slice winner) impure inline {
    slice contract_data = get_data().begin_parse();
    slice owner_address = contract_data~load_msg_addr();

    set_data(begin_cell().store_slice(owner_address).store_slice(winner).store_int(0, 16).end_cell());
}

() reward_winner(slice winner_address) impure inline {

    var [balance, _] = get_balance();

    throw_unless(444, balance > const::min_balance + const::owner_fee);

    int withdraw_amount = min(3000000000, balance - const::min_balance - const::owner_fee);

    int mode = 0;
    var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(winner_address)
            .store_coins(withdraw_amount)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);

    send_raw_message(msg.end_cell(), mode);
}

slice raffle() impure inline {
    randomize_lt(); int winner = rand(4);
    int i = 0;

    slice contract_data = get_data().begin_parse();
    slice owner_address = contract_data~load_msg_addr();
    slice prev_winner = contract_data~load_msg_addr();

    int num_part = contract_data~load_int(16);
    cell participants = contract_data~load_dict();

    builder winner_builder = begin_cell();
    while (i < 4) {

        var (participant_address, flag) = participants.idict_get?(16, i);

        if (flag == 0) {
            throw(666);
        }

        if (i == winner) {
            winner_builder~store_slice(participant_address); 
            reward_winner(participant_address);
            i = 11;
        } else {
            i = i + 1;
        }
    }

    cell winner_cell = winner_builder.end_cell();
    slice winner_address = winner_cell.begin_parse();
    
    return winner_address~load_msg_addr();
}

() store_address(slice new_address) impure inline {

    slice contract_data = get_data().begin_parse();

    ;; Default stored values
    slice owner_address = contract_data~load_msg_addr();
    slice prev_winner = contract_data~load_msg_addr();
    int total_num_participants = contract_data~load_int(16);

    ;; Max number of participants - 11
    throw_unless(666, total_num_participants < 4);
    
    if (total_num_participants == 0){
        cell participants = new_dict();
        participants~idict_set(16, total_num_participants, new_address);

        cell new_contract_data = begin_cell()
            .store_slice(owner_address)
            .store_slice(prev_winner)
            .store_int(total_num_participants + 1, 16)
            .store_dict(participants)
            .end_cell();
        
        set_data(new_contract_data);
    } else {
        cell participants = contract_data~load_dict();
        participants~idict_set(16, total_num_participants, new_address);

        cell new_contract_data = begin_cell()
            .store_slice(owner_address)
            .store_slice(prev_winner)
            .store_int(total_num_participants + 1, 16)
            .store_dict(participants)
            .end_cell();
        
        set_data(new_contract_data);
    }

    if (total_num_participants == 3) {
        slice winner = raffle();
        restart_raffle(winner);
    }

}

() ownerWithdraw(slice sender_address) impure inline {
    slice contract_data = get_data().begin_parse();
    slice owner_address = contract_data~load_msg_addr();
    slice prev_winner = contract_data~load_msg_addr();
    int num_participants = contract_data~load_int(16);
    
    throw_unless(333, num_participants == 0);

    ;; Throw Exception unless the sender is the owner
    throw_unless(111, equal_slice_bits(sender_address, owner_address));

    var [balance, _] = get_balance();

    ;; Throw Exception unless the balance is greater than the minimum balance
    throw_unless(444, balance > const::min_balance);
    
    int withdraw_amount = balance - const::min_balance;
    int mode = 0;
    var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(owner_address)
            .store_coins(withdraw_amount)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);

    send_raw_message(msg.end_cell(), mode);
}

;; OPCODES : 0 - deploy, 1 - deposit, 2 - withdraw
;; Msg Body should store 3 bits integer opcode
() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {

    ;; Parse the message flags
    slice cs = in_msg.begin_parse();
    int msg_flags = cs~load_int(3);

    ;; Ignore bounced messages
    int is_bounced = cs~load_int(1);
    if (is_bounced == 1){
        return();
    }

    ;; Get the sender address and opcode
    slice sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_int(16);
    
    ;; Just for deploy
    if (op == 0) {
        slice contract_data = get_data().begin_parse();
        slice owner_address = contract_data~load_msg_addr();

        throw_unless(111, equal_slice_bits(sender_address, owner_address));
        return();
    }

    ;; Deposit for participation in the raffle
    if (op == 1) {
        ;; Revert transaction if the deposit amount is not equal to the required deposit amount (0.1 ton)
        throw_unless(555, msg_value == const::deposit);

        store_address(sender_address);
        return();
    }
    
    ;; Withdraw the owner fee
    if (op == 2) {
        ownerWithdraw(sender_address);
        return();
    }
    ;; Throw exception unless valid opcode is provided
    throw(999);

}

int get_num_participants() method_id {
    slice contract_data = get_data().begin_parse();
    slice owner_address = contract_data~load_msg_addr();
    slice prev_winner = contract_data~load_msg_addr();

    int num_participants = contract_data~load_int(16);
    return num_participants;
}

slice get_recent_winner() method_id {
    slice contract_data = get_data().begin_parse();
    slice owner_address = contract_data~load_msg_addr();
    slice prev_winner = contract_data~load_msg_addr();

    return prev_winner;
}

slice get_owner_address() method_id {
    slice contract_data = get_data().begin_parse();
    slice owner_address = contract_data~load_msg_addr();
    
    return owner_address;
}

int get_current_balance() method_id {
    var [balance, _] = get_balance();
    return balance;
}